/*
 * Nibble - Concurrent Log-Structured Memory for Many-Core Key-Value Stores
 *
 * (c) 2017 Hewlett Packard Enterprise Development LP.
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Lesser General Public License as published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version. This program is distributed in the hope that
 * it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>. As an exception, the copyright holders of this Library
 * grant you permission to (i) compile an Application with the Library, and (ii) distribute the Application
 * containing code generated by the Library and added to the Application during this compilation process
 * under terms of your choice, provided you also meet the terms and conditions of the Application license.
 */


// Macros go in separate module to satisfy circular dependencies

//==----------------------------------------------------==//
//      Compiler hints
//==----------------------------------------------------==//

/// Wrapper for intrinsics::likely
#[macro_export]
macro_rules! likely {
    ( $b:expr ) => { unsafe { intrinsics::likely($b) } }
}

/// Wrapper for intrinsics::unlikely
#[macro_export]
macro_rules! unlikely {
    ( $b:expr ) => { unsafe { intrinsics::unlikely($b) } }
}

//==----------------------------------------------------==//
//      Segment macros
//==----------------------------------------------------==//

/// Instantiate new Segment as a SegmentRef
#[macro_export]
macro_rules! seg_ref {
    ( $id:expr, $sock:expr, $slot:expr, $blocks:expr ) => {
        Arc::new( pl::RwLock::new(
                Segment::new($id, $sock, $slot, $blocks)
                ))
    }
}

/// Instantiate new Segment with zero blocks
#[macro_export]
macro_rules! seg_ref_empty {
    ( $id:expr ) => {
        Arc::new( RefCell::new(
                Segment::empty($id)
                ))
    }
}

/// Make a new segment manager and package into a shareable reference
#[macro_export]
macro_rules! segmgr_ref {
    ( $segsz:expr, $bytes:expr ) => {
        Arc::new( pl::Mutex::new(
                SegmentManager::new( $segsz, $bytes)
                ))
    }
}

//==----------------------------------------------------==//
//      Index macros
//==----------------------------------------------------==//

/// Make a new index and package into a shareable reference
#[macro_export]
macro_rules! index_ref {
    ( ) => {
        Arc::new( Index::new() )
    }
}

//==----------------------------------------------------==//
//      Compactor macros
//==----------------------------------------------------==//

/// Make a new compactor instance.
#[macro_export]
macro_rules! comp_ref {
    ( $manager:expr, $index:expr ) => {
        Arc::new( pl::Mutex::new(
                Compactor::new( $manager, $index )
                ))
    }
}

