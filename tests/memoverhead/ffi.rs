/*
 * Nibble - Concurrent Log-Structured Memory for Many-Core Key-Value Stores
 *
 * (c) 2017 Hewlett Packard Enterprise Development LP.
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Lesser General Public License as published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version. This program is distributed in the hope that
 * it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>. As an exception, the copyright holders of this Library
 * grant you permission to (i) compile an Application with the Library, and (ii) distribute the Application
 * containing code generated by the Library and added to the Application during this compilation process
 * under terms of your choice, provided you also meet the terms and conditions of the Application license.
 */


#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![feature(const_fn)]

extern crate kvs;

// use kvs::clock;
use kvs::common::{Pointer,ErrorCode,rdrand,rdrandq};
// use kvs::epoch;
use kvs::logger;
// use kvs::memory;
use kvs::lsm::{self,LSM};
use kvs::numa::{self,NodeId};
// use kvs::sched::*;
use kvs::segment::{ObjDesc,SEGMENT_SIZE};
// use rand::Rng;
// use std::collections::VecDeque;
// use std::mem;
// use std::sync::Arc;
// use std::sync::atomic::*;
use std::thread::{self,JoinHandle};
use std::time::{Instant,Duration};
use std::ptr::null;

static mut KVS: Pointer<LSM> = Pointer(null::<LSM>());

#[no_mangle] pub extern
fn kvs_init(cap: usize, nitems: usize) {
	logger::enable();
	println!("# LSM allocating...");
	//let kvs: Box<LSM> = Box::new(LSM::default());
	let kvs: Box<LSM> = Box::new(LSM::new2(cap,nitems));
	println!("# LSM enabling compaction on Node 0");
    kvs.enable_compaction(NodeId(0));
	let p = Box::into_raw(kvs);
	println!("# LSM @ {:?}", p);
	unsafe {
		KVS.0 = p;
	}
}

// return 0 if ok else 1
#[no_mangle] pub extern
fn kvs_put(key: u64, len: u64) -> i32 {
	let kvs: &LSM = unsafe { &*KVS.0 };
	// println!("put {:x}", key);
    let obj = ObjDesc::null(key, len as usize);
    match kvs.put_where(&obj, lsm::PutPolicy::Specific(0)) {
        Ok(_) => 0i32,
        Err(e) => match e {
            ErrorCode::OutOfMemory => 1i32,
            _ => panic!("error put: {:?}", e),
        },
    }
}

// return 0 if ok else 1
#[no_mangle] pub extern
fn kvs_del(key: u64) -> i32 {
	let kvs: &LSM = unsafe { &*KVS.0 };
	// println!("del {:x}", key);
	match kvs.del_object(key) {
        Ok(_) => 0i32,
        Err(e) => {
            println!("ERROR: kvs_del: {:?}", e);
            1i32
        },
    }
}
