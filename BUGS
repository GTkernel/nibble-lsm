x SEGV in Nibble::get_object within the memcpy
x Segments didn't seem to decr live size
x 'index out of bounds: the len is 128 but the index is 142'
    segment.rs 592
x entry headers are corrupt. read either by app or compaction
    mprotecting doesn't trigger anything, must be during append

x double-check that each compaction thread does NOT have segments from
  other sockets in its local list. -- seems ok

x what happens when object moved from one socket to another? live
  bytes need to be updated in other socket's epoch table

x does compaction handle ientry correctly? with socket 0 it may 'just
  work' because the sock value is ghosted --> compaction may be okay
  with objects moved elsewhere since it updates local segments only.
  moved objects are handled as gained free memory. even if we don't
  handle ientry in compaction, it basically becomes a larger key, and
  virtual addresses will not overlap across sockets anyway (except if
  we use spacejmp..)

x put_object might need to handle decr/incr live_bytes correctly
  between sockets

* if one socket runs out of memory (even when overall capacity is not
  near 100%) that socket compactor may deadlock

* there seem to be an undeterministic number of segments which are
  OPEN, waiting in reclamation. i've noticed at most 1 OPEN segment in
  the set of candidate segments (for compaction). where? why? OPEN
  segments should ONLY be as head segments, otherwise they are closed


===================== Performance/Other Issues =======================

x Replace all use of Mutex/RwLock with those in parking_lot
- verify all uses of transmute
- have compaction turn on imeediately when data is low, not wait 1sec
- don't forget writes are bottlenecked by locks on LogHead
- don't use rdrand or other rand generator in a critical path
