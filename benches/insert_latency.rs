/*
 * Nibble - Concurrent Log-Structured Memory for Many-Core Key-Value Stores
 *
 * (c) 2017 Hewlett Packard Enterprise Development LP.
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Lesser General Public License as published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version. This program is distributed in the hope that
 * it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>. As an exception, the copyright holders of this Library
 * grant you permission to (i) compile an Application with the Library, and (ii) distribute the Application
 * containing code generated by the Library and added to the Application during this compilation process
 * under terms of your choice, provided you also meet the terms and conditions of the Application license.
 */


/*
 * Test simple put latencies, local, remote, varying object lengths.
 *
 * This should run with only one thread (cargo bench should behave
 * this way by default).
 */

#![feature(test)]

/// Specify amount of memory in GiB LSM should allocate for the
/// logs.  The index will acquire more memory for the hash tables.
const LSM_CAPACITY: usize = 30;

extern crate test;
extern crate kvs;
extern crate rand;

#[macro_use]
extern crate lazy_static;

use rand::Rng;
use test::Bencher;

use std::mem;
use std::sync::{Once, ONCE_INIT};

use kvs::common::Pointer;
use kvs::lsm::{LSM,PutPolicy};
use kvs::segment::ObjDesc;
use kvs::sched::pin_cpu;
use kvs::logger;
use kvs::numa::{self,NodeId};

// TODO Put unique objects (will not perform atomic decrement of old
// segment).

// TODO test objects larger than block, and segment
// TODO put_object which must traverse chunks
// TODO a get_object which must traverse chunks
// TODO test we can determine live vs dead entries in segment
// TODO test specific cases where header cross block boundaries

type KeyType = u64;

// Initializing this takes a while, so we do it once and reuse across
// bench iterations. Each outer function is called many times, as well
// as each invocation of Bencher::iter.
lazy_static! {
    pub static ref KVS: LSM =
        LSM::new(LSM_CAPACITY<<30);
}

static START: Once = ONCE_INIT;

// If compaction must be on, uncomment below.
fn setup() {
    START.call_once( || {
        logger::enable();
        unsafe { pin_cpu(0); }
        //let nsockets = numa::NODE_MAP.sockets();
        //for s in 0..nsockets {
        //    KVS.enable_compaction(NodeId(s));
        //}
    });
}

fn insert_n(b: &mut Bencher, p: PutPolicy,
            kvs: &LSM, len: usize) {
    let mut rng = rand::thread_rng();
    let key = rng.gen::<u64>();
    let val: Vec<u8> = Vec::with_capacity(len);
    let obj = ObjDesc::new(key, Pointer(val.as_ptr()), len);
    b.iter( || { kvs.put_where(&obj,p) });
}

fn local_insert_n(b: &mut Bencher, kvs: &LSM, len: usize) {
    let policy = PutPolicy::Specific(0);
    insert_n(b, policy, kvs, len);
}

fn remote_insert_n(b: &mut Bencher, kvs: &LSM, len: usize) {
    let node = numa::NODE_MAP.sockets() - 1;
    let policy = PutPolicy::Specific(node);
    insert_n(b, policy, kvs, len);
}

// ---- Local tests ----

#[bench]
fn local_insert_16(b: &mut Bencher) {
    setup();
    let len = 16_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_30(b: &mut Bencher) {
    setup();
    let len = 30_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_60(b: &mut Bencher) {
    setup();
    let len = 60_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_100(b: &mut Bencher) {
    setup();
    let len = 100_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_200(b: &mut Bencher) {
    setup();
    let len = 200_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_500(b: &mut Bencher) {
    setup();
    let len = 500_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_1000(b: &mut Bencher) {
    setup();
    let len = 1000_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_2000(b: &mut Bencher) {
    setup();
    let len = 3000_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

#[bench]
fn local_insert_4000(b: &mut Bencher) {
    setup();
    let len = 4000_usize - mem::size_of::<KeyType>();
    local_insert_n(b, &KVS, len);
}

// ---- Distant tests ----

#[bench]
fn remote_insert_16(b: &mut Bencher) {
    setup();
    let len = 16_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_30(b: &mut Bencher) {
    setup();
    let len = 30_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_60(b: &mut Bencher) {
    setup();
    let len = 60_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_100(b: &mut Bencher) {
    setup();
    let len = 100_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_200(b: &mut Bencher) {
    setup();
    let len = 200_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_500(b: &mut Bencher) {
    setup();
    let len = 500_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_1000(b: &mut Bencher) {
    setup();
    let len = 1000_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_2000(b: &mut Bencher) {
    setup();
    let len = 3000_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

#[bench]
fn remote_insert_4000(b: &mut Bencher) {
    setup();
    let len = 4000_usize - mem::size_of::<KeyType>();
    remote_insert_n(b, &KVS, len);
}

